<!DOCTYPE Html>
<html style="width:100%;height:100%;">
<head>
<title>Module 7</title>
<script src="https://code.jquery.com/jquery-2.2.3.min.js" integrity="sha256-a23g1Nt4dtEYOj7bR+vTu7+T8VP13humZFBJNIYoEJo=" crossorigin="anonymous"></script>
</head>
<body style="width:100%;height:100%;margin:0;">
<svg id="svgele" height="100%" width="100%">


</svg>
<script type="text/javascript">

	// Warn if overriding existing method
	if(Array.prototype.equals)
	    console.warn("Overriding existing Array.prototype.equals. Possible causes: New API defines the method, there's a framework conflict or you've got double inclusions in your code.");
	// attach the .equals method to Array's prototype to call it on any array
	Array.prototype.equals = function (array) {
	    // if the other array is a falsy value, return
	    if (!array)
		return false;

	    // compare lengths - can save a lot of time 
	    if (this.length != array.length)
		return false;

	    for (var i = 0, l=this.length; i < l; i++) {
		// Check if we have nested arrays
		if (this[i] instanceof Array && array[i] instanceof Array) {
		    // recurse into the nested arrays
		    if (!this[i].equals(array[i]))
		        return false;       
		}           
		else if (this[i] != array[i]) { 
		    // Warning - two different object instances will never be equal: {x:20} != {x:20}
		    return false;   
		}           
	    }       
	    return true;
	}
	// Hide method from for-in loops
	Object.defineProperty(Array.prototype, "equals", {enumerable: false});

    function remove(ary, value){
        tempary = [];
        for (var val in ary){
            if (!ary[val].equals(value)){
                tempary.push(ary[val]);
            }
        }
        return tempary;
    }

    function drawCircle(){
        max_so_far = -1;
        max_fir = [];
        max_sec = [];
        if (points.length > 1){
            for(var cod in points){
                tmp = parseInt(cod)+1;
                for(tmp; tmp<points.length;tmp++){
                    var dx = points[cod][0]-points[tmp][0];
                    var dy = points[cod][1]-points[tmp][1];
                    rad = Math.sqrt(((dx*dx)+(dy*dy)))/2
                    if (rad>max_so_far){
                        max_fir = points[cod];
                        max_sec = points[tmp];
                        max_so_far = rad;
                    }
                }
            }
            var cx = (max_fir[0]+max_sec[0])/2;
            var cy = (max_fir[1]+max_sec[1])/2;
            rad = max_so_far;
            console.log(cx, cy, rad, max_so_far, max_fir, max_sec);
        }
        else{
            cx = points[0][0];
            cy = points[0][1];
            rad = 15; 
            console.log(cx, cy, rad, max_so_far, max_fir, max_sec);
        }
        $("#circle").remove();
        sv.innerHTML += '<circle id="circle" cx="'+cx+'" cy="'+cy+'" r="'+rad+'" fill-opacity="0.1" />';
    
    }
    var points = [];
    var sv = document.getElementById('svgele');
    $(sv).on("click", function(e){
        temparr = [e.pageX, e.pageY];
        
        if($('#cir'+e.pageX+e.pageY).length){
            $('#cir'+e.pageX+e.pageY).remove()
            console.log(points);
            points = remove(points, temparr);
            console.log(points);
        }
        else{
        points.push(temparr);
        sv.innerHTML += '<circle id="cir'+e.pageX+e.pageY+'" cx="'+e.pageX+'" cy="'+e.pageY+'" r="4" fill="black" />';
        }
        drawCircle();
});
</script>
</body>
</html>
